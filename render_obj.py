import cv2
import json
import math
import sys
import pygame
import os
import numpy as np

from pygame.locals import *
from pygame.constants import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *

from obj_loader import *

# Path to the camera info json file generated by 'camera_calibration.py'
CAMERA_INFO_PATH = "camera_info.json"

# Path to the output directory for storing the new images
OUTPUT_DIR = "output"

# Set to allow freeroam of the object after image generation
FREEROAM = True

# Render the different camera positions and superimpose object onto the original images
GENERATE_IMAGES = True

# Set to apply distortion to the OPENGL object, or disable to use distorted images from the generated by 'camera_calibration.py'
DISTORT_OPENGL = True

# Normalise the object to origin
NORMALISE_OBJ = True

# Set to manually set the height/width of the render window (WARNING: MUST BE NONE TO WORK FOR GENERATING IMAGES)
MANUAL_WIDTH = None #1920
MANUAL_HEIGHT = None #1080

# The number of checkerboard squares to move the object (starting from the bottom left)
SQUARE_TRANSLATION = (3, 1, 0)

# The amount to rotate the object to align with checkerboard
SQUARE_ROTATION = (0, 0, 0)

OBJ_PATH = "objects"
OBJ_NAME = "3DModel_LowPoly.obj"

# Matrix to convert OpenCV coordinate system to OpenGL
INVERSE_MATRIX = np.array([[ 1.0, 1.0, 1.0, 1.0],
                           [-1.0,-1.0,-1.0,-1.0],
                           [-1.0,-1.0,-1.0,-1.0],
                           [ 1.0, 1.0, 1.0, 1.0]])

# Initialise perspective matrix
def init_perspective(viewport, camera_matrix):
    width, height = viewport
    
    focal_length_x = camera_matrix[0][0]
    focal_length_y = camera_matrix[1][1]

    fov_x = math.degrees(2 * math.atan(width / (2 * focal_length_x)))
    fov_y = math.degrees(2 * math.atan(height / (2 * focal_length_y)))

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fov_y, width / height, 1, 100.0)
    glEnable(GL_DEPTH_TEST)
    glMatrixMode(GL_MODELVIEW)

# Initialise object lighting
def init_lighting():
    glLightfv(GL_LIGHT0, GL_POSITION, (-40, 200, 100, 0.0))
    glLightfv(GL_LIGHT0, GL_AMBIENT, (0.2, 0.2, 0.2, 1.0))
    glLightfv(GL_LIGHT0, GL_DIFFUSE, (0.5, 0.5, 0.5, 1.0))
    glEnable(GL_LIGHT0)
    glEnable(GL_LIGHTING)
    glEnable(GL_COLOR_MATERIAL)
    glEnable(GL_DEPTH_TEST)
    glShadeModel(GL_SMOOTH) 

# Initialise frame information
def init_frame():

    # Clear colour and depth buffers (ready for new frame)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    # Set background colour
    glClearColor(1.0, 1.0, 1.0, 1.0)
    glLoadIdentity()

# Rotate camera
def rotate_cam(rx, ry, rz):
    glRotate(math.degrees(rx), 1, 0, 0)
    glRotate(math.degrees(ry), 0, 1, 0)
    glRotate(math.degrees(rz), 0, 0, 1)

# Translate camera
def trans_cam(tx, ty, tz):
    glTranslate(tx, ty, -tz)

# Get pixel data from current colour frame and save to image
def get_opengl_frame(width, height):
    glPixelStorei(GL_PACK_ALIGNMENT, 1)
    data = glReadPixels(0, 0, width, height, GL_BGR, GL_UNSIGNED_BYTE)
    image = np.frombuffer(data, dtype=np.uint8)
    image = image.reshape((height, width, 3))
    image = cv2.flip(image, 0)  # Flip the image vertically if needed
    return image

# Calculate colour mask by removing white background
def calculate_background_mask(img, threshold_value = 200):
    gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    _, mask = cv2.threshold(gray_img, threshold_value, 255, cv2.THRESH_BINARY)
    return mask

# Combine segmented object and background images
def combine_images(img1, img2, mask):
    idx=(mask==0)
    combined_img = np.copy(img2)
    combined_img[idx]=img1[idx]
    return combined_img

# Converts the OpenCV coordinate system to OpenGL
def convert_opencv_coords_to_opengl(rvec_opencv, tvec_opencv): 

    # Convert euler angles to rotation matrix   
    rotation_matrix = cv2.Rodrigues(rvec_opencv)[0]

    # Convert rotation and translation vectors to view matrix
    view_matrix = np.array([[rotation_matrix[0][0], rotation_matrix[0][1], rotation_matrix[0][2],  tvec_opencv[0]],                        
                        [rotation_matrix[1][0], rotation_matrix[1][1], rotation_matrix[1][2], tvec_opencv[1]],
                        [rotation_matrix[2][0], rotation_matrix[2][1], rotation_matrix[2][2], tvec_opencv[2]],
                        [0.0, 0.0, 0.0, 1.0]])

    # Multiply by inverse matrix to convert coordiante system to OpenGL
    view_matrix = view_matrix * INVERSE_MATRIX                                           

    return np.transpose(view_matrix)

def add_obj_to_render(view_matrix, obj, trans = (0,0,0), rot=(0,0,0)):
    init_frame()
    
    glPushMatrix()                                  

    # Set view matrix as model-view matrix in the pipeline
    glLoadMatrixd(view_matrix)  
    
    # Rotate obj by 180 degrees (match image)
    rotate_cam(math.pi, 0, 0)
    
    # Rotate obj 
    rotate_cam(rot[0], rot[1], rot[2])

    # Translate obj
    trans_cam(trans[0], trans[1], trans[2])

    # Add object to pipeline
    glCallList(obj.gl_list)
    glPopMatrix()
    glFlush()

    pygame.time.wait(100)
    pygame.display.flip()
    pygame.time.wait(100)

# Distorts an image according to the camera matrix and distoriton values
# WARNING: CURRENTLY NOT WORKING
def distort_image(img, camera_matrix, distortion):
    image_size = np.array(img.shape[:2])[::-1]

    camera_matrix = np.array(camera_matrix)
    distortion = np.array(distortion)

    # Generate coords and calcualte distortion maps
    x_coords, y_coords = np.meshgrid(np.arange(image_size[0]), np.arange(image_size[1]))
    pts_distort = np.stack((x_coords, y_coords), axis=-1).astype(np.float32).reshape(-1, 1, 2)
    pts_ud = cv2.undistortPoints(pts_distort, camera_matrix, distortion, R=camera_matrix)
    map_x = pts_ud[:, :, 0].reshape(image_size[::-1]).astype(np.float32)
    map_y = pts_ud[:, :, 1].reshape(image_size[::-1]).astype(np.float32)

    # Distort the image
    return cv2.remap(img, map_x, map_y, interpolation=cv2.INTER_LINEAR)

if __name__ == "__main__":

    # Load camera data
    with open(CAMERA_INFO_PATH, "r") as camera_info_file:
        camera_info = json.load(camera_info_file)

    if not os.path.exists(OUTPUT_DIR):
        os.mkdir(OUTPUT_DIR)

    # Width and height of the object to be rendered
    width = camera_info["image_data"][0]["width"] if MANUAL_WIDTH is None else MANUAL_WIDTH 
    height =  camera_info["image_data"][0]["height"] if MANUAL_HEIGHT is None else MANUAL_HEIGHT

    viewport = (width, height)
    
    # Initialise pygame
    pygame.init()
    clock = pygame.time.Clock()
    srf = pygame.display.set_mode(viewport, OPENGL | DOUBLEBUF)

    # Initialise Lighting
    init_lighting()

    # Load in object model
    obj = OBJ(OBJ_PATH, OBJ_NAME, swapyz=False, normalise=NORMALISE_OBJ) 

    init_perspective(viewport, camera_info["camera_matrix"])

    # Clear buffers
    init_frame()

    if GENERATE_IMAGES:
        for current_info in camera_info["image_data"]:

            print(f"Rendering current image: {current_info['img_name']}")

            clock.tick(30)
            
            img_dir = "image_dir_path" if DISTORT_OPENGL else "undistort_image_dir_path"

            original_image = cv2.imread(os.path.join(camera_info[img_dir], current_info["img_name"]))

            # View matrix that positions camera correctly
            view_matrix = convert_opencv_coords_to_opengl(np.array(current_info["rvec"]), np.array(current_info["tvec"]))

            # Initialise and add object to pipeline 
            # HAD TO PERFORM THIS TWICE TO ENSURE THAT OBJECT WAS CORRECTLY RENDERED WHEN RETRIEVING PIXEL VALUES (not sure why)
            add_obj_to_render(view_matrix, obj, trans=SQUARE_TRANSLATION, rot=SQUARE_ROTATION)
            add_obj_to_render(view_matrix, obj, trans=SQUARE_TRANSLATION, rot=SQUARE_ROTATION)

            # Get rendered image 
            rendered_image = get_opengl_frame(viewport[0], viewport[1])

            if DISTORT_OPENGL:
                rendered_image = distort_image(rendered_image, camera_info["camera_matrix"], camera_info["distortion"])

            # Calculate object mask
            mask = calculate_background_mask(rendered_image)

            #cv2.imwrite(f"{os.path.join(OUTPUT_DIR, current_info['img_name'])}", rendered_image)

            # Save combined object and background
            superimposed_img = combine_images(rendered_image, original_image, mask)
            cv2.imwrite(f"{os.path.join(OUTPUT_DIR, current_info['img_name'])}", superimposed_img)

            print()

    if FREEROAM:
        print("Starting Freeroam")

        # Set default translation and rotation for camera
        rx, ry, rz = (0, 0, 0)
        tx, ty, tz = (0, 0, 50)

        rotate = move = False

        current_save = 0

        while True:
            clock.tick(30)
            for e in pygame.event.get():

                # User quits application
                if e.type == QUIT:
                    sys.exit()

                # User presses escape
                elif e.type == KEYDOWN and e.key == K_ESCAPE:
                    sys.exit()

                # Save the current render
                elif e.type == KEYDOWN and e.key == K_0:
                    print("Saving image")

                    img_name = f"save_{current_save}.png"

                    rendered_image = get_opengl_frame(viewport[0], viewport[1])
                    cv2.imwrite(f"{os.path.join(OUTPUT_DIR, img_name)}", rendered_image)

                    current_save += 1

                # Show current camera rotation and translation
                elif e.type == KEYDOWN and e.key == K_1:
                    print("Current translation: ", tx , ty, tz)
                    print("Current rotation: ", rx, ry, rz)

                # User presses a mouse button
                elif e.type == MOUSEBUTTONDOWN:
                    
                    # Scroll wheel forward
                    if e.button == 4: 
                        tz = max(1, tz-1)

                    # Scroll wheel backwards
                    if e.button == 5:
                        tz += 1

                    # Left mouse
                    elif e.button == 1:
                        rotate = True

                    # Right mouse
                    elif e.button == 3:
                        move = True

                elif e.type == MOUSEBUTTONUP:
                    if e.button == 1:
                        rotate = False
                    elif e.button == 3:
                        move = False

                # Alter rotation/translation values after mouse down interation
                elif e.type == MOUSEMOTION:
                    i, j = e.rel
                    if rotate:
                        rx += i/50.0
                        ry += j/50.0
                    if move:
                        tx += i/50.0
                        ty -= j/50.0
            
            # Initialise current frame
            init_frame()

            # Translate and rotate camera to set position
            trans_cam(tx , ty, tz)
            rotate_cam(rx, ry, rz)

            # Add object to pipeline
            glCallList(obj.gl_list)

            # Display the OpenGL frame
            pygame.display.flip()

    print("Finished Rendering")
